unit DataService_Impl;

{----------------------------------------------------------------------------}
{ This unit was automatically generated by the RemObjects SDK after reading  }
{ the RODL file associated with this project .                               }
{                                                                            }
{ This is where you are supposed to code the implementation of your objects. }
{----------------------------------------------------------------------------}

{$I RemObjects.inc}

interface

uses
  {vcl:} Classes, SysUtils, 
  {RemObjects:} uROXMLIntf, uROClientIntf, uROTypes, uROServer, uROServerIntf,
  uROSessions,
  {Generated:} DataMon_Intf, UMgrDBWriter, ULibFun, UMgrMCGS;

type
  { TDataService }
  TDataService = class(TRORemotable, IDataService)
  private
    FListA,FListB: TStrings;
    //列表
    FBufLen: Integer;
    FBuffer: TMCGSParamItems;
    //缓冲
  protected
    { IDataService methods }
    function UpdateDataList(const nDataList: DataList): Boolean;
    function UpdateDataStrs(const nStr: AnsiString): Boolean;
  public
    constructor Create; override;
    destructor Destroy; override;
  end;

implementation

{$I Link.inc}
uses USysConst;

const
  cBufSize = 100;

constructor TDataService.Create;
begin
  inherited;
  FListA := TStringList.Create;
  FListB := TStringList.Create;
  SetLength(FBuffer, cBufSize);
end;

destructor TDataService.Destroy;
begin
  FListA.Free;
  FListB.Free;
  inherited;
end;

function TDataService.UpdateDataList(const nDataList: DataList): Boolean;
begin
  Result := True;
end;

//Desc: 接收数据
function TDataService.UpdateDataStrs(const nStr: AnsiString): Boolean;
var i,nIdx: Integer;
begin
  {$IFDEF DEBUG}
  ShowSyncLog(nStr);
  {$ENDIF}

  Result := True;
  if not SplitStr(nStr, FListA, 0, '|') then Exit;

  nIdx := 0;
  FBufLen := 0;

  for i:=0 to FListA.Count - 1 do
  try
    if not SplitStr(FListA[i], FListB, 43, ':') then Continue;
    //all:ch,dh,Serial,w x 4,s x 4,fj,bj,rl,mw ext

    with FBuffer[nIdx] do
    begin
      FCH := FListB[0];
      FDH := FListB[1];
      FSerial := StrToInt(FListB[2]);
      Fw1 := StrToFloat(FListB[3]);
      Fw2 := StrToFloat(FListB[4]);
      Fw3 := StrToFloat(FListB[5]);
      Fw4 := StrToFloat(FListB[6]);
      Fs1 := StrToFloat(FListB[7]);
      Fs2 := StrToFloat(FListB[8]);
      Fs3 := StrToFloat(FListB[9]);
      Fs4 := StrToFloat(FListB[10]);
      //xxxxx
      Ffj1 := StrToInt(FListB[11]);
      Ffj2 := StrToInt(FListB[12]);
      Ffj3 := StrToInt(FListB[13]);
      Ffj4 := StrToInt(FListB[14]);
      Ffj5 := StrToInt(FListB[15]);
      Ffjo := StrToInt(FListB[16]);
      Ffjc := StrToInt(FListB[17]);
      Ftfjb := StrToInt(FListB[18]);
      Ftfbj := StrToInt(FListB[19]);
      Frs1 := StrToInt(FListB[20]);
      Frs2 := StrToInt(FListB[21]);
      Frs3 := StrToInt(FListB[22]);
      Frs4 := StrToInt(FListB[23]);
      //xxxxx
      Frld := StrToFloat(FListB[24]);
      Frlh := StrToFloat(FListB[25]);
      Fllt := StrToFloat(FListB[26]);
      Fllk := StrToFloat(FListB[27]);
      Frll := StrToFloat(FListB[28]);
      Fslt := StrToInt(FListB[29]);
      fslk := StrToInt(FListB[30]);
      Fsww := StrToFloat(FListB[31]);
      Fcold := StrToInt(FListB[32]);
      Fhot := StrToInt(FListB[33]);
      //xxxxx
      Fweight := StrToFloat(FListB[34]);
      Fmw := StrToFloat(FListB[35]);
      Faq := StrToFloat(FListB[36]);
      Ffy1 := StrToFloat(FListB[37]);
      Ffy2 := StrToFloat(FListB[38]);
      Fslkd := StrToFloat(FListB[39]);
      Fslb := StrToFloat(FListB[40]);
      Fccl := StrToFloat(FListB[41]);
      Fccr := StrToFloat(FListB[42]);
    end;

    Inc(nIdx);
    Inc(FBufLen);

    if nIdx >= cBufSize then nIdx := 0;
    if FBufLen > cBufSize then FBufLen := cBufSize;
  except
    //ignor any error
  end;

  if FBufLen > 0 then
    gDBWriteManager.WriteItems(FBuffer, FBufLen);
  //write items
end;

end.
