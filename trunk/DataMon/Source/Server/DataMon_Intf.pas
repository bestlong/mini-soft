unit DataMon_Intf;

{----------------------------------------------------------------------------}
{ This unit was automatically generated by the RemObjects SDK after reading  }
{ the RODL file associated with this project .                               }
{                                                                            }
{ Do not modify this unit manually, or your changes will be lost when this   }
{ unit is regenerated the next time you compile the project.                 }
{----------------------------------------------------------------------------}

{$I RemObjects.inc}

interface

uses
  {vcl:} Classes, TypInfo,
  {RemObjects:} uROXMLIntf, uROClasses, uROClient, uROTypes, uROClientIntf;

const
  { Library ID }
  LibraryUID = '{1902382C-CD5F-4F94-ACC0-103A4370A1FB}';
  TargetNamespace = '';

  { Service Interface ID's }
  IDataService_IID : TGUID = '{A8E2A5A5-F1A3-4C1A-B4F5-A448232736BB}';

  { Event ID's }

type
  { Forward declarations }
  IDataService = interface;

  DataList = class;

  DataItem = class;


  { DataItem }

  { Description:
      数据项 }
  DataItem = class(TROComplexType)
  private
    fFarmID: AnsiString;
    fCageID: AnsiString;
    fCageIdx: Integer;
    fw1: Decimal;
    fw2: Decimal;
    fw3: Decimal;
    fw4: Decimal;
    fs1: Decimal;
    fs2: Decimal;
    fs3: Decimal;
    fs4: Decimal;
    ffj: Decimal;
    fbj: Decimal;
  public
    procedure Assign(iSource: TPersistent); override;
    procedure ReadComplex(ASerializer: TObject); override;
    procedure WriteComplex(ASerializer: TObject); override;
  published
    property FarmID:AnsiString read fFarmID write fFarmID;
    property CageID:AnsiString read fCageID write fCageID;
    property CageIdx:Integer read fCageIdx write fCageIdx;
    property w1:Decimal read fw1 write fw1;
    property w2:Decimal read fw2 write fw2;
    property w3:Decimal read fw3 write fw3;
    property w4:Decimal read fw4 write fw4;
    property s1:Decimal read fs1 write fs1;
    property s2:Decimal read fs2 write fs2;
    property s3:Decimal read fs3 write fs3;
    property s4:Decimal read fs4 write fs4;
    property fj:Decimal read ffj write ffj;
    property bj:Decimal read fbj write fbj;
  end;

  { DataItemCollection }
  DataItemCollection = class(TROCollection)
  protected
    constructor Create(aItemClass: TCollectionItemClass); overload;
    function GetItems(aIndex: integer): DataItem;
    procedure SetItems(aIndex: integer; const Value: DataItem);
  public
    constructor Create; overload;
    function Add: DataItem; reintroduce;
    procedure SaveToArray(anArray: DataList);
    procedure LoadFromArray(anArray: DataList);
    property Items[Index: integer]:DataItem read GetItems write SetItems; default;
  end;

  { DataList }

  { Description:
      有效数据组 }
  DataList_DataItem = array of DataItem;
  DataList = class(TROArray)
  private
    fCount: Integer;
    fItems : DataList_DataItem;
  protected
    procedure Grow; virtual;
    function GetItems(aIndex: integer): DataItem;
    procedure SetItems(aIndex: integer; const Value: DataItem);
    function GetCount: integer; override;
  public
    class function GetItemType: PTypeInfo; override;
    class function GetItemClass: TClass; override;
    class function GetItemSize: integer; override;

    function GetItemRef(aIndex: integer): pointer; override;
    procedure SetItemRef(aIndex: integer; Ref: pointer); override;
    procedure Clear; override;
    procedure Delete(aIndex: integer); override;
    procedure Resize(ElementCount: integer); override;

    procedure Assign(iSource:TPersistent); override;
    procedure ReadComplex(ASerializer: TObject); override;
    procedure WriteComplex(ASerializer: TObject); override;
    function Add: DataItem; overload;
    function Add(const Value: DataItem):integer; overload;

    property Count : integer read GetCount;
    property Items[Index: integer]:DataItem read GetItems write SetItems; default;
    property InnerArray: DataList_DataItem read fItems;
  end;

  { IDataService }

  { Description:
      数据服务 }
  IDataService = interface
    ['{A8E2A5A5-F1A3-4C1A-B4F5-A448232736BB}']
    function UpdateDataList(const nDataList: DataList): Boolean;
    function UpdateDataStrs(const nStr: AnsiString): Boolean;
  end;

  { CoDataService }
  CoDataService = class
    class function Create(const aMessage: IROMessage; aTransportChannel: IROTransportChannel): IDataService;
  end;

  { TDataService_Proxy }
  TDataService_Proxy = class(TROProxy, IDataService)
  protected
    function __GetInterfaceName:string; override;

    function UpdateDataList(const nDataList: DataList): Boolean;
    function UpdateDataStrs(const nStr: AnsiString): Boolean;
  end;

implementation

uses
  {vcl:} SysUtils,
  {RemObjects:} uROEventRepository, uROSerializer, uRORes;

{ DataList }

procedure DataList.Assign(iSource: TPersistent);
var lSource:DataList;
    i:integer;
begin
  if (iSource is DataList) then begin
    lSource := DataList(iSource);
    Clear();
    Resize(lSource.Count);

    for i := 0 to Count-1 do begin
      if Assigned(lSource.Items[i]) then begin
        Items[i].Assign(lSource.Items[i]);
      end;
    end;
  end
  else begin
    inherited Assign(iSource);
  end;
end;

class function DataList.GetItemType: PTypeInfo;
begin
  result := TypeInfo(DataItem);
end;

class function DataList.GetItemClass: TClass;
begin
  result := DataItem;
end;

class function DataList.GetItemSize: integer;
begin
  result := SizeOf(DataItem);
end;

function DataList.GetItems(aIndex: integer): DataItem;
begin
  if (aIndex < 0) or (aIndex >= Count) then RaiseError(err_ArrayIndexOutOfBounds,[aIndex]);
  result := fItems[aIndex];
end;

function DataList.GetItemRef(aIndex: integer): pointer;
begin
  if (aIndex < 0) or (aIndex >= Count) then RaiseError(err_ArrayIndexOutOfBounds,[aIndex]);
  result := fItems[aIndex];
end;

procedure DataList.SetItemRef(aIndex: integer; Ref: pointer);
begin
  if (aIndex < 0) or (aIndex >= Count) then RaiseError(err_ArrayIndexOutOfBounds,[aIndex]);
  if Ref <> fItems[aIndex] then begin
    if fItems[aIndex] <> nil then fItems[aIndex].Free;
    fItems[aIndex] := Ref;
  end;
end;

procedure DataList.Clear;
var i: integer;
begin
  for i := 0 to (Count-1) do fItems[i].Free();
  SetLength(fItems, 0);
  FCount := 0;
end;

procedure DataList.Delete(aIndex: integer);
var i: integer;
begin
  if (aIndex>=Count) then RaiseError(err_InvalidIndex, [aIndex]);

  fItems[aIndex].Free();

  if (aIndex<Count-1) then
    for i := aIndex to Count-2 do fItems[i] := fItems[i+1];

  SetLength(fItems, Count-1);
  Dec(FCount);
end;

procedure DataList.SetItems(aIndex: integer; const Value: DataItem);
begin
  if (aIndex < 0) or (aIndex >= Count) then RaiseError(err_ArrayIndexOutOfBounds,[aIndex]);
  if fItems[aIndex] <> Value then begin
    fItems[aIndex].Free;
    fItems[aIndex] := Value;
  end;
end;

procedure DataList.Resize(ElementCount: integer);
var i: Integer;
begin
  if fCount = ElementCount then Exit;
  for i := FCount -1 downto ElementCount do
    FItems[i].Free;
  SetLength(fItems, ElementCount);
  for i := FCount to ElementCount -1 do
    FItems[i] := DataItem.Create;
  FCount := ElementCount;
end;

function DataList.GetCount: integer;
begin
  result := FCount;
end;

procedure DataList.Grow;
var
  Delta, Capacity: Integer;
begin
  Capacity := Length(fItems);
  if Capacity > 64 then
    Delta := Capacity div 4
  else
    if Capacity > 8 then
      Delta := 16
   else
      Delta := 4;
  SetLength(fItems, Capacity + Delta);
end;

function DataList.Add: DataItem;
begin
  result := DataItem.Create;
  Add(Result);
end;

function DataList.Add(const Value:DataItem): integer;
begin
  Result := Count;
  if Length(fItems) = Result then
    Grow;
  fItems[result] := Value;
  Inc(fCount);
end;

procedure DataList.ReadComplex(ASerializer: TObject);
var
  lval: DataItem;
  i: integer;
begin
  for i := 0 to Count-1 do begin
    with TROSerializer(ASerializer) do
      ReadStruct(GetArrayElementName(GetItemType, GetItemRef(i)), DataItem, lval, i);
    Items[i] := lval;
  end;
end;

procedure DataList.WriteComplex(ASerializer: TObject);
var
  i: integer;
begin
  for i := 0 to Count-1 do
    with TROSerializer(ASerializer) do
      WriteStruct(GetArrayElementName(GetItemType, GetItemRef(i)), fItems[i], DataItem, i);
end;

{ DataItem }

procedure DataItem.Assign(iSource: TPersistent); 
var lSource: DataMon_Intf.DataItem;
begin
  inherited Assign(iSource);
  if (iSource is DataMon_Intf.DataItem) then begin
    lSource := DataMon_Intf.DataItem(iSource);
    FarmID := lSource.FarmID;
    CageID := lSource.CageID;
    CageIdx := lSource.CageIdx;
    w1 := lSource.w1;
    w2 := lSource.w2;
    w3 := lSource.w3;
    w4 := lSource.w4;
    s1 := lSource.s1;
    s2 := lSource.s2;
    s3 := lSource.s3;
    s4 := lSource.s4;
    fj := lSource.fj;
    bj := lSource.bj;
  end;
end;

procedure DataItem.ReadComplex(ASerializer: TObject);
var
  l_bj: Decimal;
  l_CageID: AnsiString;
  l_CageIdx: Integer;
  l_FarmID: AnsiString;
  l_fj: Decimal;
  l_s1: Decimal;
  l_s2: Decimal;
  l_s3: Decimal;
  l_s4: Decimal;
  l_w1: Decimal;
  l_w2: Decimal;
  l_w3: Decimal;
  l_w4: Decimal;
begin
  if TROSerializer(ASerializer).RecordStrictOrder then begin
    l_FarmID := FarmID;
    TROSerializer(ASerializer).ReadAnsiString('FarmID', l_FarmID);
    FarmID := l_FarmID;
    l_CageID := CageID;
    TROSerializer(ASerializer).ReadAnsiString('CageID', l_CageID);
    CageID := l_CageID;
    l_CageIdx := CageIdx;
    TROSerializer(ASerializer).ReadInteger('CageIdx', otSLong, l_CageIdx);
    CageIdx := l_CageIdx;
    l_w1 := w1;
    TROSerializer(ASerializer).ReadDecimal('w1', l_w1);
    w1 := l_w1;
    l_w2 := w2;
    TROSerializer(ASerializer).ReadDecimal('w2', l_w2);
    w2 := l_w2;
    l_w3 := w3;
    TROSerializer(ASerializer).ReadDecimal('w3', l_w3);
    w3 := l_w3;
    l_w4 := w4;
    TROSerializer(ASerializer).ReadDecimal('w4', l_w4);
    w4 := l_w4;
    l_s1 := s1;
    TROSerializer(ASerializer).ReadDecimal('s1', l_s1);
    s1 := l_s1;
    l_s2 := s2;
    TROSerializer(ASerializer).ReadDecimal('s2', l_s2);
    s2 := l_s2;
    l_s3 := s3;
    TROSerializer(ASerializer).ReadDecimal('s3', l_s3);
    s3 := l_s3;
    l_s4 := s4;
    TROSerializer(ASerializer).ReadDecimal('s4', l_s4);
    s4 := l_s4;
    l_fj := fj;
    TROSerializer(ASerializer).ReadDecimal('fj', l_fj);
    fj := l_fj;
    l_bj := bj;
    TROSerializer(ASerializer).ReadDecimal('bj', l_bj);
    bj := l_bj;
  end
  else begin
    l_bj := bj;
    TROSerializer(ASerializer).ReadDecimal('bj', l_bj);
    bj := l_bj;
    l_CageID := CageID;
    TROSerializer(ASerializer).ReadAnsiString('CageID', l_CageID);
    CageID := l_CageID;
    l_CageIdx := CageIdx;
    TROSerializer(ASerializer).ReadInteger('CageIdx', otSLong, l_CageIdx);
    CageIdx := l_CageIdx;
    l_FarmID := FarmID;
    TROSerializer(ASerializer).ReadAnsiString('FarmID', l_FarmID);
    FarmID := l_FarmID;
    l_fj := fj;
    TROSerializer(ASerializer).ReadDecimal('fj', l_fj);
    fj := l_fj;
    l_s1 := s1;
    TROSerializer(ASerializer).ReadDecimal('s1', l_s1);
    s1 := l_s1;
    l_s2 := s2;
    TROSerializer(ASerializer).ReadDecimal('s2', l_s2);
    s2 := l_s2;
    l_s3 := s3;
    TROSerializer(ASerializer).ReadDecimal('s3', l_s3);
    s3 := l_s3;
    l_s4 := s4;
    TROSerializer(ASerializer).ReadDecimal('s4', l_s4);
    s4 := l_s4;
    l_w1 := w1;
    TROSerializer(ASerializer).ReadDecimal('w1', l_w1);
    w1 := l_w1;
    l_w2 := w2;
    TROSerializer(ASerializer).ReadDecimal('w2', l_w2);
    w2 := l_w2;
    l_w3 := w3;
    TROSerializer(ASerializer).ReadDecimal('w3', l_w3);
    w3 := l_w3;
    l_w4 := w4;
    TROSerializer(ASerializer).ReadDecimal('w4', l_w4);
    w4 := l_w4;
  end;
end;

procedure DataItem.WriteComplex(ASerializer: TObject);
var
  l_bj: Decimal;
  l_CageID: AnsiString;
  l_CageIdx: Integer;
  l_FarmID: AnsiString;
  l_fj: Decimal;
  l_s1: Decimal;
  l_s2: Decimal;
  l_s3: Decimal;
  l_s4: Decimal;
  l_w1: Decimal;
  l_w2: Decimal;
  l_w3: Decimal;
  l_w4: Decimal;
begin
  if TROSerializer(ASerializer).RecordStrictOrder then begin
    TROSerializer(ASerializer).ChangeClass(DataItem);
    l_FarmID := FarmID;
    TROSerializer(ASerializer).WriteAnsiString('FarmID', l_FarmID);
    l_CageID := CageID;
    TROSerializer(ASerializer).WriteAnsiString('CageID', l_CageID);
    l_CageIdx := CageIdx;
    TROSerializer(ASerializer).WriteInteger('CageIdx', otSLong, l_CageIdx);
    l_w1 := w1;
    TROSerializer(ASerializer).WriteDecimal('w1', l_w1);
    l_w2 := w2;
    TROSerializer(ASerializer).WriteDecimal('w2', l_w2);
    l_w3 := w3;
    TROSerializer(ASerializer).WriteDecimal('w3', l_w3);
    l_w4 := w4;
    TROSerializer(ASerializer).WriteDecimal('w4', l_w4);
    l_s1 := s1;
    TROSerializer(ASerializer).WriteDecimal('s1', l_s1);
    l_s2 := s2;
    TROSerializer(ASerializer).WriteDecimal('s2', l_s2);
    l_s3 := s3;
    TROSerializer(ASerializer).WriteDecimal('s3', l_s3);
    l_s4 := s4;
    TROSerializer(ASerializer).WriteDecimal('s4', l_s4);
    l_fj := fj;
    TROSerializer(ASerializer).WriteDecimal('fj', l_fj);
    l_bj := bj;
    TROSerializer(ASerializer).WriteDecimal('bj', l_bj);
  end
  else begin
    l_bj := bj;
    TROSerializer(ASerializer).WriteDecimal('bj', l_bj);
    l_CageID := CageID;
    TROSerializer(ASerializer).WriteAnsiString('CageID', l_CageID);
    l_CageIdx := CageIdx;
    TROSerializer(ASerializer).WriteInteger('CageIdx', otSLong, l_CageIdx);
    l_FarmID := FarmID;
    TROSerializer(ASerializer).WriteAnsiString('FarmID', l_FarmID);
    l_fj := fj;
    TROSerializer(ASerializer).WriteDecimal('fj', l_fj);
    l_s1 := s1;
    TROSerializer(ASerializer).WriteDecimal('s1', l_s1);
    l_s2 := s2;
    TROSerializer(ASerializer).WriteDecimal('s2', l_s2);
    l_s3 := s3;
    TROSerializer(ASerializer).WriteDecimal('s3', l_s3);
    l_s4 := s4;
    TROSerializer(ASerializer).WriteDecimal('s4', l_s4);
    l_w1 := w1;
    TROSerializer(ASerializer).WriteDecimal('w1', l_w1);
    l_w2 := w2;
    TROSerializer(ASerializer).WriteDecimal('w2', l_w2);
    l_w3 := w3;
    TROSerializer(ASerializer).WriteDecimal('w3', l_w3);
    l_w4 := w4;
    TROSerializer(ASerializer).WriteDecimal('w4', l_w4);
  end;
end;

{ DataItemCollection }
constructor DataItemCollection.Create;
begin
  inherited Create(DataItem);
end;

constructor DataItemCollection.Create(aItemClass: TCollectionItemClass);
begin
  inherited Create(aItemClass);
end;

function DataItemCollection.Add: DataItem;
begin
  result := DataItem(inherited Add);
end;

function DataItemCollection.GetItems(aIndex: integer): DataItem;
begin
  result := DataItem(inherited Items[aIndex]);
end;

procedure DataItemCollection.LoadFromArray(anArray: DataList);
var i : integer;
begin
  Clear;
  for i := 0 to (anArray.Count-1) do
    Add.Assign(anArray[i]);
end;

procedure DataItemCollection.SaveToArray(anArray: DataList);
var i : integer;
begin
  anArray.Clear;
  anArray.Resize(Count);
  for i := 0 to (Count-1) do begin
    anArray[i] := DataItem.Create;
    anArray[i].Assign(Items[i]);
  end;
end;

procedure DataItemCollection.SetItems(aIndex: integer; const Value: DataItem);
begin
  DataItem(inherited Items[aIndex]).Assign(Value);
end;

{ CoDataService }

class function CoDataService.Create(const aMessage: IROMessage; aTransportChannel: IROTransportChannel): IDataService;
begin
  result := TDataService_Proxy.Create(aMessage, aTransportChannel);
end;

{ TDataService_Proxy }

function TDataService_Proxy.__GetInterfaceName:string;
begin
  result := 'DataService';
end;

function TDataService_Proxy.UpdateDataList(const nDataList: DataList): Boolean;
begin
  try
    __Message.InitializeRequestMessage(__TransportChannel, 'DataMon', __InterfaceName, 'UpdateDataList');
    __Message.Write('nDataList', TypeInfo(DataMon_Intf.DataList), nDataList, []);
    __Message.Finalize;

    __TransportChannel.Dispatch(__Message);

    __Message.Read('Result', TypeInfo(Boolean), result, []);
  finally
    __Message.UnsetAttributes(__TransportChannel);
    __Message.FreeStream;
  end
end;

function TDataService_Proxy.UpdateDataStrs(const nStr: AnsiString): Boolean;
begin
  try
    __Message.InitializeRequestMessage(__TransportChannel, 'DataMon', __InterfaceName, 'UpdateDataStrs');
    __Message.Write('nStr', TypeInfo(AnsiString), nStr, []);
    __Message.Finalize;

    __TransportChannel.Dispatch(__Message);

    __Message.Read('Result', TypeInfo(Boolean), result, []);
  finally
    __Message.UnsetAttributes(__TransportChannel);
    __Message.FreeStream;
  end
end;

initialization
  RegisterROClass(DataItem);
  RegisterROClass(DataList);
  RegisterProxyClass(IDataService_IID, TDataService_Proxy);


finalization
  UnregisterROClass(DataItem);
  UnregisterROClass(DataList);
  UnregisterProxyClass(IDataService_IID);

end.
